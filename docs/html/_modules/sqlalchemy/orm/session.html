<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sqlalchemy.orm.session &#8212; RAMSTK 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <link rel="shortcut icon" type="image/png" href="../../../_static/favicon.png" />
    <meta name="viewport" content="width=device-width,initial-scale=0.8">
    
    

  </head><body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="responsive-menu"><a href="#sidebar-anchor" title="Navigation">&#9776;</a></li>
        <li><a href="../../../index.html">RAMSTK 2.0.0 documentation</a> &#187;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
    
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sqlalchemy.orm.session</h1><div class="highlight"><pre>
<span></span><span class="c1"># orm/session.py</span>
<span class="c1"># Copyright (C) 2005-2019 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>
<span class="sd">&quot;&quot;&quot;Provides the Session class and related utilities.&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">attributes</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">identity</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">loading</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">persistence</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">query</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">state</span> <span class="k">as</span> <span class="n">statelib</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_class_to_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_none_set</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_state_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">instance_str</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">object_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">object_state</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">state_str</span>
<span class="kn">from</span> <span class="nn">.deprecated_interfaces</span> <span class="k">import</span> <span class="n">SessionExtension</span>
<span class="kn">from</span> <span class="nn">.unitofwork</span> <span class="k">import</span> <span class="n">UOWTransaction</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">engine</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">sa_exc</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">sql</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..inspection</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">expression</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">sql_util</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Session&quot;</span><span class="p">,</span> <span class="s2">&quot;SessionTransaction&quot;</span><span class="p">,</span> <span class="s2">&quot;SessionExtension&quot;</span><span class="p">,</span> <span class="s2">&quot;sessionmaker&quot;</span><span class="p">]</span>

<span class="n">_sessions</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;Weak-referencing dictionary of :class:`.Session` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an :class:`.InstanceState`, return the :class:`.Session`</span>
<span class="sd">        associated, if any.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sessions</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">_SessionClassMethods</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class-level methods for :class:`.Session`, :class:`.sessionmaker`.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;1.3&quot;</span><span class="p">,</span>
        <span class="s2">&quot;The :meth:`.Session.close_all` method is deprecated and will be &quot;</span>
        <span class="s2">&quot;removed in a future release.  Please refer to &quot;</span>
        <span class="s2">&quot;:func:`.session.close_all_sessions`.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">close_all</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close *all* sessions in memory.&quot;&quot;&quot;</span>

        <span class="n">close_all_sessions</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.orm.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">identity_key</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">orm_util</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an identity key.</span>

<span class="sd">        This is an alias of :func:`.util.identity_key`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">orm_util</span><span class="o">.</span><span class="n">identity_key</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which an object belongs.</span>

<span class="sd">        This is an alias of :func:`.object_session`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>


<span class="n">ACTIVE</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">&quot;ACTIVE&quot;</span><span class="p">)</span>
<span class="n">PREPARED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">&quot;PREPARED&quot;</span><span class="p">)</span>
<span class="n">COMMITTED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">&quot;COMMITTED&quot;</span><span class="p">)</span>
<span class="n">DEACTIVE</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">&quot;DEACTIVE&quot;</span><span class="p">)</span>
<span class="n">CLOSED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">&quot;CLOSED&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SessionTransaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A :class:`.Session`-level transaction.</span>

<span class="sd">    :class:`.SessionTransaction` is a mostly behind-the-scenes object</span>
<span class="sd">    not normally referenced directly by application code.   It coordinates</span>
<span class="sd">    among multiple :class:`.Connection` objects, maintaining a database</span>
<span class="sd">    transaction for each one individually, committing or rolling them</span>
<span class="sd">    back all at once.   It also provides optional two-phase commit behavior</span>
<span class="sd">    which can augment this coordination operation.</span>

<span class="sd">    The :attr:`.Session.transaction` attribute of :class:`.Session`</span>
<span class="sd">    refers to the current :class:`.SessionTransaction` object in use, if any.</span>
<span class="sd">    The :attr:`.SessionTransaction.parent` attribute refers to the parent</span>
<span class="sd">    :class:`.SessionTransaction` in the stack of :class:`.SessionTransaction`</span>
<span class="sd">    objects.  If this attribute is ``None``, then this is the top of the stack.</span>
<span class="sd">    If non-``None``, then this :class:`.SessionTransaction` refers either</span>
<span class="sd">    to a so-called &quot;subtransaction&quot; or a &quot;nested&quot; transaction.  A</span>
<span class="sd">    &quot;subtransaction&quot; is a scoping concept that demarcates an inner portion</span>
<span class="sd">    of the outermost &quot;real&quot; transaction.  A nested transaction, which</span>
<span class="sd">    is indicated when the :attr:`.SessionTransaction.nested`</span>
<span class="sd">    attribute is also True, indicates that this :class:`.SessionTransaction`</span>
<span class="sd">    corresponds to a SAVEPOINT.</span>

<span class="sd">    **Life Cycle**</span>

<span class="sd">    A :class:`.SessionTransaction` is associated with a :class:`.Session`</span>
<span class="sd">    in its default mode of ``autocommit=False`` immediately, associated</span>
<span class="sd">    with no database connections.  As the :class:`.Session` is called upon</span>
<span class="sd">    to emit SQL on behalf of various :class:`.Engine` or :class:`.Connection`</span>
<span class="sd">    objects, a corresponding :class:`.Connection` and associated</span>
<span class="sd">    :class:`.Transaction` is added to a collection within the</span>
<span class="sd">    :class:`.SessionTransaction` object, becoming one of the</span>
<span class="sd">    connection/transaction pairs maintained by the</span>
<span class="sd">    :class:`.SessionTransaction`.  The start of a :class:`.SessionTransaction`</span>
<span class="sd">    can be tracked using the :meth:`.SessionEvents.after_transaction_create`</span>
<span class="sd">    event.</span>

<span class="sd">    The lifespan of the :class:`.SessionTransaction` ends when the</span>
<span class="sd">    :meth:`.Session.commit`, :meth:`.Session.rollback` or</span>
<span class="sd">    :meth:`.Session.close` methods are called.  At this point, the</span>
<span class="sd">    :class:`.SessionTransaction` removes its association with its parent</span>
<span class="sd">    :class:`.Session`.   A :class:`.Session` that is in ``autocommit=False``</span>
<span class="sd">    mode will create a new :class:`.SessionTransaction` to replace it</span>
<span class="sd">    immediately, whereas a :class:`.Session` that&#39;s in ``autocommit=True``</span>
<span class="sd">    mode will remain without a :class:`.SessionTransaction` until the</span>
<span class="sd">    :meth:`.Session.begin` method is called.  The end of a</span>
<span class="sd">    :class:`.SessionTransaction` can be tracked using the</span>
<span class="sd">    :meth:`.SessionEvents.after_transaction_end` event.</span>

<span class="sd">    **Nesting and Subtransactions**</span>

<span class="sd">    Another detail of :class:`.SessionTransaction` behavior is that it is</span>
<span class="sd">    capable of &quot;nesting&quot;.  This means that the :meth:`.Session.begin` method</span>
<span class="sd">    can be called while an existing :class:`.SessionTransaction` is already</span>
<span class="sd">    present, producing a new :class:`.SessionTransaction` that temporarily</span>
<span class="sd">    replaces the parent :class:`.SessionTransaction`.   When a</span>
<span class="sd">    :class:`.SessionTransaction` is produced as nested, it assigns itself to</span>
<span class="sd">    the :attr:`.Session.transaction` attribute, and it additionally will assign</span>
<span class="sd">    the previous :class:`.SessionTransaction` to its :attr:`.Session.parent`</span>
<span class="sd">    attribute.  The behavior is effectively a</span>
<span class="sd">    stack, where :attr:`.Session.transaction` refers to the current head of</span>
<span class="sd">    the stack, and the :attr:`.SessionTransaction.parent` attribute allows</span>
<span class="sd">    traversal up the stack until :attr:`.SessionTransaction.parent` is</span>
<span class="sd">    ``None``, indicating the top of the stack.</span>

<span class="sd">    When the scope of :class:`.SessionTransaction` is ended via</span>
<span class="sd">    :meth:`.Session.commit` or :meth:`.Session.rollback`, it restores its</span>
<span class="sd">    parent :class:`.SessionTransaction` back onto the</span>
<span class="sd">    :attr:`.Session.transaction` attribute.</span>

<span class="sd">    The purpose of this stack is to allow nesting of</span>
<span class="sd">    :meth:`.Session.rollback` or :meth:`.Session.commit` calls in context</span>
<span class="sd">    with various flavors of :meth:`.Session.begin`. This nesting behavior</span>
<span class="sd">    applies to when :meth:`.Session.begin_nested` is used to emit a</span>
<span class="sd">    SAVEPOINT transaction, and is also used to produce a so-called</span>
<span class="sd">    &quot;subtransaction&quot; which allows a block of code to use a</span>
<span class="sd">    begin/rollback/commit sequence regardless of whether or not its enclosing</span>
<span class="sd">    code block has begun a transaction.  The :meth:`.flush` method, whether</span>
<span class="sd">    called explicitly or via autoflush, is the primary consumer of the</span>
<span class="sd">    &quot;subtransaction&quot; feature, in that it wishes to guarantee that it works</span>
<span class="sd">    within in a transaction block regardless of whether or not the</span>
<span class="sd">    :class:`.Session` is in transactional mode when the method is called.</span>

<span class="sd">    Note that the flush process that occurs within the &quot;autoflush&quot; feature</span>
<span class="sd">    as well as when the :meth:`.Session.flush` method is used **always**</span>
<span class="sd">    creates a :class:`.SessionTransaction` object.   This object is normally</span>
<span class="sd">    a subtransaction, unless the :class:`.Session` is in autocommit mode</span>
<span class="sd">    and no transaction exists at all, in which case it&#39;s the outermost</span>
<span class="sd">    transaction.   Any event-handling logic or other inspection logic</span>
<span class="sd">    needs to take into account whether a :class:`.SessionTransaction`</span>
<span class="sd">    is the outermost transaction, a subtransaction, or a &quot;nested&quot; / SAVEPOINT</span>
<span class="sd">    transaction.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`.Session.rollback`</span>

<span class="sd">        :meth:`.Session.commit`</span>

<span class="sd">        :meth:`.Session.begin`</span>

<span class="sd">        :meth:`.Session.begin_nested`</span>

<span class="sd">        :attr:`.Session.is_active`</span>

<span class="sd">        :meth:`.SessionEvents.after_transaction_create`</span>

<span class="sd">        :meth:`.SessionEvents.after_transaction_end`</span>

<span class="sd">        :meth:`.SessionEvents.after_commit`</span>

<span class="sd">        :meth:`.SessionEvents.after_rollback`</span>

<span class="sd">        :meth:`.SessionEvents.after_soft_rollback`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rollback_exception</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="o">=</span> <span class="n">nested</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">ACTIVE</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span> <span class="ow">and</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t start a SAVEPOINT transaction when no existing &quot;</span>
                <span class="s2">&quot;transaction is in progress&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_take_snapshot</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The parent :class:`.SessionTransaction` of this</span>
<span class="sd">        :class:`.SessionTransaction`.</span>

<span class="sd">        If this attribute is ``None``, indicates this</span>
<span class="sd">        :class:`.SessionTransaction` is at the top of the stack, and</span>
<span class="sd">        corresponds to a real &quot;COMMIT&quot;/&quot;ROLLBACK&quot;</span>
<span class="sd">        block.  If non-``None``, then this is either a &quot;subtransaction&quot;</span>
<span class="sd">        or a &quot;nested&quot; / SAVEPOINT transaction.  If the</span>
<span class="sd">        :attr:`.SessionTransaction.nested` attribute is ``True``, then</span>
<span class="sd">        this is a SAVEPOINT, and if ``False``, indicates this a subtransaction.</span>

<span class="sd">        .. versionadded:: 1.0.16 - use ._parent for previous versions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="n">nested</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;Indicates if this is a nested, or SAVEPOINT, transaction.</span>

<span class="sd">    When :attr:`.SessionTransaction.nested` is True, it is expected</span>
<span class="sd">    that :attr:`.SessionTransaction.parent` will be True as well.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">ACTIVE</span>

    <span class="k">def</span> <span class="nf">_assert_active</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prepared_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">rollback_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">deactive_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">closed_msg</span><span class="o">=</span><span class="s2">&quot;This transaction is closed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">COMMITTED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This session is in &#39;committed&#39; state; no further &quot;</span>
                <span class="s2">&quot;SQL can be emitted within this transaction.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">PREPARED</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepared_ok</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is in &#39;prepared&#39; state; no further &quot;</span>
                    <span class="s2">&quot;SQL can be emitted within this transaction.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">DEACTIVE</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">deactive_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rollback_ok</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;This Session&#39;s transaction has been rolled back &quot;</span>
                        <span class="s2">&quot;due to a previous exception during flush.&quot;</span>
                        <span class="s2">&quot; To begin a new transaction with this Session, &quot;</span>
                        <span class="s2">&quot;first issue Session.rollback().&quot;</span>
                        <span class="s2">&quot; Original exception was: </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">deactive_ok</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;This session is in &#39;inactive&#39; state, due to the &quot;</span>
                        <span class="s2">&quot;SQL transaction being rolled back; no further &quot;</span>
                        <span class="s2">&quot;SQL can be emitted within this transaction.&quot;</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">CLOSED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ResourceClosedError</span><span class="p">(</span><span class="n">closed_msg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_transaction_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindkey</span><span class="p">,</span> <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">bindkey</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SessionTransaction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iterate_self_and_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upto</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">current</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="n">upto</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Transaction </span><span class="si">%s</span><span class="s2"> is not on the active transaction list&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">upto</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_take_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_dirty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_key_switches</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_restore_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restore the restoration state taken before a transaction began.</span>

<span class="sd">        Corresponds to a rollback.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="n">to_expunge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">(</span><span class="n">to_expunge</span><span class="p">,</span> <span class="n">to_transient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># we probably can do this conditionally based on</span>
            <span class="c1"># if we expunged or not, but safe_discard does that anyway</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="c1"># restore the old key</span>
            <span class="n">s</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">oldkey</span>

            <span class="c1"># now restore the object, but only if we didn&#39;t expunge</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_expunge</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">revert_deletion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty_only</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">modified</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the restoration state taken before a transaction began.</span>

<span class="sd">        Corresponds to a commit.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">expire_on_commit</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

            <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Connection is already established for the &quot;</span>
                    <span class="s2">&quot;given bind; execution_options ignored&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">bind</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">conn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">engine</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span>
                <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">engine</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;Session already has a Connection associated for the &quot;</span>
                        <span class="s2">&quot;given Connection&#39;s Engine&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span><span class="o">.</span><span class="n">_contextual_connect</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_twophase</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="o">.</span><span class="n">engine</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">conn</span><span class="p">,</span>
            <span class="n">transaction</span><span class="p">,</span>
            <span class="n">conn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bind</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_begin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;twophase&#39; mode not enabled, or not root transaction; &quot;</span>
                <span class="s2">&quot;can&#39;t prepare.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_prepare_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_flush_guard</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                    <span class="s2">&quot;Over 100 subsequent flushes have occurred within &quot;</span>
                    <span class="s2">&quot;session.commit() - is an after_flush() hook &quot;</span>
                    <span class="s2">&quot;creating new objects?&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">PREPARED</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PREPARED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">COMMITTED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_snapshot</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_capture_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rollback_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">rollback_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ACTIVE</span><span class="p">,</span> <span class="n">PREPARED</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">transaction</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                            <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

                        <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">DEACTIVE</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_rollback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">rollback_err</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">DEACTIVE</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
                            <span class="n">transaction</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span>
                                <span class="n">dirty_only</span><span class="o">=</span><span class="n">transaction</span><span class="o">.</span><span class="n">nested</span>
                            <span class="p">)</span>
                    <span class="n">boundary</span> <span class="o">=</span> <span class="n">transaction</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">DEACTIVE</span>

        <span class="n">sess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">rollback_err</span>
            <span class="ow">and</span> <span class="n">sess</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">sess</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">()</span>
        <span class="p">):</span>

            <span class="c1"># if items were added, deleted, or mutated</span>
            <span class="c1"># here, we need to re-restore the snapshot</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Session&#39;s state has been changed on &quot;</span>
                <span class="s2">&quot;a non-active transaction - this state &quot;</span>
                <span class="s2">&quot;will be discarded.&quot;</span>
            <span class="p">)</span>
            <span class="n">boundary</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span><span class="n">dirty_only</span><span class="o">=</span><span class="n">boundary</span><span class="o">.</span><span class="n">nested</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">_capture_exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_rollback_exception</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rollback_err</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="o">*</span><span class="n">rollback_err</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_soft_rollback</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">connection</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">autoclose</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">invalidate</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">autoclose</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">CLOSED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">deactive_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">type_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manages persistence operations for ORM-mapped objects.</span>

<span class="sd">    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">public_methods</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;__contains__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__iter__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;add&quot;</span><span class="p">,</span>
        <span class="s2">&quot;add_all&quot;</span><span class="p">,</span>
        <span class="s2">&quot;begin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;begin_nested&quot;</span><span class="p">,</span>
        <span class="s2">&quot;close&quot;</span><span class="p">,</span>
        <span class="s2">&quot;commit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;connection&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delete&quot;</span><span class="p">,</span>
        <span class="s2">&quot;execute&quot;</span><span class="p">,</span>
        <span class="s2">&quot;expire&quot;</span><span class="p">,</span>
        <span class="s2">&quot;expire_all&quot;</span><span class="p">,</span>
        <span class="s2">&quot;expunge&quot;</span><span class="p">,</span>
        <span class="s2">&quot;expunge_all&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flush&quot;</span><span class="p">,</span>
        <span class="s2">&quot;get_bind&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_modified&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bulk_save_objects&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bulk_insert_mappings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bulk_update_mappings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;merge&quot;</span><span class="p">,</span>
        <span class="s2">&quot;query&quot;</span><span class="p">,</span>
        <span class="s2">&quot;refresh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rollback&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scalar&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated_params</span><span class="p">(</span>
        <span class="n">weak_identity_map</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;The :paramref:`.Session.weak_identity_map` parameter as well as &quot;</span>
            <span class="s2">&quot;the strong-referencing identity map are deprecated, and will be &quot;</span>
            <span class="s2">&quot;removed in a future release.  For the use case where objects &quot;</span>
            <span class="s2">&quot;present in a :class:`.Session` need to be automatically strong &quot;</span>
            <span class="s2">&quot;referenced, see the recipe at &quot;</span>
            <span class="s2">&quot;:ref:`session_referencing_behavior` for an event-based approach &quot;</span>
            <span class="s2">&quot;to maintaining strong identity references. &quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">_enable_transaction_accounting</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;0.7&quot;</span><span class="p">,</span>
            <span class="s2">&quot;The :paramref:`.Session._enable_transaction_accounting` &quot;</span>
            <span class="s2">&quot;parameter is deprecated and will be removed in a future release.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">extension</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;0.7&quot;</span><span class="p">,</span>
            <span class="s2">&quot;:class:`.SessionExtension` is deprecated in favor of the &quot;</span>
            <span class="s2">&quot;:class:`.SessionEvents` listener interface.  The &quot;</span>
            <span class="s2">&quot;:paramref:`.Session.extension` parameter will be &quot;</span>
            <span class="s2">&quot;removed in a future release.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">autoflush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_enable_transaction_accounting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">twophase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weak_identity_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">binds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">enable_baked_queries</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a new Session.</span>

<span class="sd">        See also the :class:`.sessionmaker` function which is used to</span>
<span class="sd">        generate a :class:`.Session`-producing callable with a given</span>
<span class="sd">        set of arguments.</span>

<span class="sd">        :param autocommit:</span>

<span class="sd">          .. warning::</span>

<span class="sd">             The autocommit flag is **not for general use**, and if it is</span>
<span class="sd">             used, queries should only be invoked within the span of a</span>
<span class="sd">             :meth:`.Session.begin` / :meth:`.Session.commit` pair.  Executing</span>
<span class="sd">             queries outside of a demarcated transaction is a legacy mode</span>
<span class="sd">             of usage, and can in some cases lead to concurrent connection</span>
<span class="sd">             checkouts.</span>

<span class="sd">          Defaults to ``False``. When ``True``, the</span>
<span class="sd">          :class:`.Session` does not keep a persistent transaction running,</span>
<span class="sd">          and will acquire connections from the engine on an as-needed basis,</span>
<span class="sd">          returning them immediately after their use. Flushes will begin and</span>
<span class="sd">          commit (or possibly rollback) their own transaction if no</span>
<span class="sd">          transaction is present. When using this mode, the</span>
<span class="sd">          :meth:`.Session.begin` method is used to explicitly start</span>
<span class="sd">          transactions.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :ref:`session_autocommit`</span>

<span class="sd">        :param autoflush: When ``True``, all query operations will issue a</span>
<span class="sd">           :meth:`~.Session.flush` call to this ``Session`` before proceeding.</span>
<span class="sd">           This is a convenience feature so that :meth:`~.Session.flush` need</span>
<span class="sd">           not be called repeatedly in order for database queries to retrieve</span>
<span class="sd">           results. It&#39;s typical that ``autoflush`` is used in conjunction</span>
<span class="sd">           with ``autocommit=False``. In this scenario, explicit calls to</span>
<span class="sd">           :meth:`~.Session.flush` are rarely needed; you usually only need to</span>
<span class="sd">           call :meth:`~.Session.commit` (which flushes) to finalize changes.</span>

<span class="sd">        :param bind: An optional :class:`.Engine` or :class:`.Connection` to</span>
<span class="sd">           which this ``Session`` should be bound. When specified, all SQL</span>
<span class="sd">           operations performed by this session will execute via this</span>
<span class="sd">           connectable.</span>

<span class="sd">        :param binds: A dictionary which may specify any number of</span>
<span class="sd">           :class:`.Engine` or :class:`.Connection` objects as the source of</span>
<span class="sd">           connectivity for SQL operations on a per-entity basis.   The keys</span>
<span class="sd">           of the dictionary consist of any series of mapped classes,</span>
<span class="sd">           arbitrary Python classes that are bases for mapped classes,</span>
<span class="sd">           :class:`.Table` objects and :class:`.Mapper` objects.  The</span>
<span class="sd">           values of the dictionary are then instances of :class:`.Engine`</span>
<span class="sd">           or less commonly :class:`.Connection` objects.  Operations which</span>
<span class="sd">           proceed relative to a particular mapped class will consult this</span>
<span class="sd">           dictionary for the closest matching entity in order to determine</span>
<span class="sd">           which :class:`.Engine` should be used for a particular SQL</span>
<span class="sd">           operation.    The complete heuristics for resolution are</span>
<span class="sd">           described at :meth:`.Session.get_bind`.  Usage looks like::</span>

<span class="sd">            Session = sessionmaker(binds={</span>
<span class="sd">                SomeMappedClass: create_engine(&#39;postgresql://engine1&#39;),</span>
<span class="sd">                SomeDeclarativeBase: create_engine(&#39;postgresql://engine2&#39;),</span>
<span class="sd">                some_mapper: create_engine(&#39;postgresql://engine3&#39;),</span>
<span class="sd">                some_table: create_engine(&#39;postgresql://engine4&#39;),</span>
<span class="sd">                })</span>

<span class="sd">           .. seealso::</span>

<span class="sd">                :ref:`session_partitioning`</span>

<span class="sd">                :meth:`.Session.bind_mapper`</span>

<span class="sd">                :meth:`.Session.bind_table`</span>

<span class="sd">                :meth:`.Session.get_bind`</span>


<span class="sd">        :param \class_: Specify an alternate class other than</span>
<span class="sd">           ``sqlalchemy.orm.session.Session`` which should be used by the</span>
<span class="sd">           returned class. This is the only argument that is local to the</span>
<span class="sd">           :class:`.sessionmaker` function, and is not sent directly to the</span>
<span class="sd">           constructor for ``Session``.</span>

<span class="sd">        :param enable_baked_queries: defaults to ``True``.  A flag consumed</span>
<span class="sd">           by the :mod:`sqlalchemy.ext.baked` extension to determine if</span>
<span class="sd">           &quot;baked queries&quot; should be cached, as is the normal operation</span>
<span class="sd">           of this extension.  When set to ``False``, all caching is disabled,</span>
<span class="sd">           including baked queries defined by the calling application as</span>
<span class="sd">           well as those used internally.  Setting this flag to ``False``</span>
<span class="sd">           can significantly reduce memory use, however will also degrade</span>
<span class="sd">           performance for those areas that make use of baked queries</span>
<span class="sd">           (such as relationship loaders).   Additionally, baked query</span>
<span class="sd">           logic in the calling application or potentially within the ORM</span>
<span class="sd">           that may be malfunctioning due to cache key collisions or similar</span>
<span class="sd">           can be flagged by observing if this flag resolves the issue.</span>

<span class="sd">           .. versionadded:: 1.2</span>

<span class="sd">        :param _enable_transaction_accounting:   A</span>
<span class="sd">           legacy-only flag which when ``False`` disables *all* 0.5-style</span>
<span class="sd">           object accounting on transaction boundaries.</span>

<span class="sd">        :param expire_on_commit:  Defaults to ``True``. When ``True``, all</span>
<span class="sd">           instances will be fully expired after each :meth:`~.commit`,</span>
<span class="sd">           so that all attribute/object access subsequent to a completed</span>
<span class="sd">           transaction will load from the most recent database state.</span>

<span class="sd">        :param extension: An optional</span>
<span class="sd">           :class:`~.SessionExtension` instance, or a list</span>
<span class="sd">           of such instances, which will receive pre- and post- commit and</span>
<span class="sd">           flush events, as well as a post-rollback event.</span>

<span class="sd">        :param info: optional dictionary of arbitrary data to be associated</span>
<span class="sd">           with this :class:`.Session`.  Is available via the</span>
<span class="sd">           :attr:`.Session.info` attribute.  Note the dictionary is copied at</span>
<span class="sd">           construction time so that modifications to the per-</span>
<span class="sd">           :class:`.Session` dictionary will be local to that</span>
<span class="sd">           :class:`.Session`.</span>

<span class="sd">           .. versionadded:: 0.9.0</span>

<span class="sd">        :param query_cls:  Class which should be used to create new Query</span>
<span class="sd">          objects, as returned by the :meth:`~.Session.query` method.</span>
<span class="sd">          Defaults to :class:`.Query`.</span>

<span class="sd">        :param twophase:  When ``True``, all transactions will be started as</span>
<span class="sd">            a &quot;two phase&quot; transaction, i.e. using the &quot;two phase&quot; semantics</span>
<span class="sd">            of the database in use along with an XID.  During a</span>
<span class="sd">            :meth:`~.commit`, after :meth:`~.flush` has been issued for all</span>
<span class="sd">            attached databases, the :meth:`~.TwoPhaseTransaction.prepare`</span>
<span class="sd">            method on each database&#39;s :class:`.TwoPhaseTransaction` will be</span>
<span class="sd">            called. This allows each database to roll back the entire</span>
<span class="sd">            transaction, before each transaction is committed.</span>

<span class="sd">        :param weak_identity_map:  Defaults to ``True`` - when set to</span>
<span class="sd">           ``False``, objects placed in the :class:`.Session` will be</span>
<span class="sd">           strongly referenced until explicitly removed or the</span>
<span class="sd">           :class:`.Session` is closed.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">weak_identity_map</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">WeakInstanceDict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">StrongInstanceDict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># InstanceState-&gt;object, strong refs object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># same</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span> <span class="o">=</span> <span class="n">_new_sessionid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expire_on_commit</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_baked_queries</span> <span class="o">=</span> <span class="n">enable_baked_queries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="o">=</span> <span class="n">_enable_transaction_accounting</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">twophase</span> <span class="o">=</span> <span class="n">twophase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span> <span class="o">=</span> <span class="n">query_cls</span> <span class="k">if</span> <span class="n">query_cls</span> <span class="k">else</span> <span class="n">query</span><span class="o">.</span><span class="n">Query</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extension</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">extension</span><span class="p">):</span>
                <span class="n">SessionExtension</span><span class="o">.</span><span class="n">_adapt_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">bind</span> <span class="ow">in</span> <span class="n">binds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="n">_sessions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="n">connection_callable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">transaction</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;The current active or inactive :class:`.SessionTransaction`.&quot;&quot;&quot;</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A user-modifiable dictionary.</span>

<span class="sd">        The initial value of this dictionary can be populated using the</span>
<span class="sd">        ``info`` argument to the :class:`.Session` constructor or</span>
<span class="sd">        :class:`.sessionmaker` constructor or factory methods.  The dictionary</span>
<span class="sd">        here is always local to this :class:`.Session` and can be modified</span>
<span class="sd">        independently of all other :class:`.Session` objects.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtransactions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a transaction on this :class:`.Session`.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The :meth:`.Session.begin` method is part of a larger pattern</span>
<span class="sd">            of use with the :class:`.Session` known as **autocommit mode**.</span>
<span class="sd">            This is essentially a **legacy mode of use** and is</span>
<span class="sd">            not necessary for new applications.    The :class:`.Session`</span>
<span class="sd">            normally handles the work of &quot;begin&quot; transparently, which in</span>
<span class="sd">            turn relies upon the Python DBAPI to transparently &quot;begin&quot;</span>
<span class="sd">            transactions; there is **no need to explicitly begin transactions**</span>
<span class="sd">            when using modern :class:`.Session` programming patterns.</span>
<span class="sd">            In its default mode of ``autocommit=False``, the</span>
<span class="sd">            :class:`.Session` does all of its work within</span>
<span class="sd">            the context of a transaction, so as soon as you call</span>
<span class="sd">            :meth:`.Session.commit`, the next transaction is implicitly</span>
<span class="sd">            started when the next database operation is invoked.  See</span>
<span class="sd">            :ref:`session_autocommit` for further background.</span>

<span class="sd">        The method will raise an error if this :class:`.Session` is already</span>
<span class="sd">        inside of a transaction, unless</span>
<span class="sd">        :paramref:`~.Session.begin.subtransactions` or</span>
<span class="sd">        :paramref:`~.Session.begin.nested` are specified.  A &quot;subtransaction&quot;</span>
<span class="sd">        is essentially a code embedding pattern that does not affect the</span>
<span class="sd">        transactional state of the database connection unless a rollback is</span>
<span class="sd">        emitted, in which case the whole transaction is rolled back.  For</span>
<span class="sd">        documentation on subtransactions, please see</span>
<span class="sd">        :ref:`session_subtransactions`.</span>

<span class="sd">        :param subtransactions: if True, indicates that this</span>
<span class="sd">         :meth:`~.Session.begin` can create a &quot;subtransaction&quot;.</span>

<span class="sd">        :param nested: if True, begins a SAVEPOINT transaction and is</span>
<span class="sd">         equivalent to calling :meth:`~.Session.begin_nested`. For</span>
<span class="sd">         documentation on SAVEPOINT transactions, please see</span>
<span class="sd">         :ref:`session_begin_nested`.</span>

<span class="sd">        :return: the :class:`.SessionTransaction` object.  Note that</span>
<span class="sd">         :class:`.SessionTransaction`</span>
<span class="sd">         acts as a Python context manager, allowing :meth:`.Session.begin`</span>
<span class="sd">         to be used in a &quot;with&quot; block.  See :ref:`session_autocommit` for</span>
<span class="sd">         an example.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_autocommit`</span>

<span class="sd">            :meth:`.Session.begin_nested`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subtransactions</span> <span class="ow">or</span> <span class="n">nested</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_begin</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;A transaction is already begun.  Use &quot;</span>
                    <span class="s2">&quot;subtransactions=True to allow subtransactions.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">SessionTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>  <span class="c1"># needed for __enter__/__exit__ hook</span>

    <span class="k">def</span> <span class="nf">begin_nested</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a &quot;nested&quot; transaction on this Session, e.g. SAVEPOINT.</span>

<span class="sd">        The target database(s) and associated drivers must support SQL</span>
<span class="sd">        SAVEPOINT for this method to function correctly.</span>

<span class="sd">        For documentation on SAVEPOINT</span>
<span class="sd">        transactions, please see :ref:`session_begin_nested`.</span>

<span class="sd">        :return: the :class:`.SessionTransaction` object.  Note that</span>
<span class="sd">         :class:`.SessionTransaction` acts as a context manager, allowing</span>
<span class="sd">         :meth:`.Session.begin_nested` to be used in a &quot;with&quot; block.</span>
<span class="sd">         See :ref:`session_begin_nested` for a usage example.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_begin_nested`</span>

<span class="sd">            :ref:`pysqlite_serializable` - special workarounds required</span>
<span class="sd">            with the SQLite driver in order for SAVEPOINT to work</span>
<span class="sd">            correctly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rollback the current transaction in progress.</span>

<span class="sd">        If no transaction is in progress, this method is a pass-through.</span>

<span class="sd">        This method rolls back the current transaction or nested transaction</span>
<span class="sd">        regardless of subtransactions being in effect.  All subtransactions up</span>
<span class="sd">        to the first real transaction are closed.  Subtransactions occur when</span>
<span class="sd">        :meth:`.begin` is called multiple times.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_rollback`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush pending changes and commit the current transaction.</span>

<span class="sd">        If no transaction is in progress, this method raises an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError`.</span>

<span class="sd">        By default, the :class:`.Session` also expires all database</span>
<span class="sd">        loaded state on all ORM-managed attributes after transaction commit.</span>
<span class="sd">        This so that subsequent operations load the most recent</span>
<span class="sd">        data from the database.   This behavior can be disabled using</span>
<span class="sd">        the ``expire_on_commit=False`` option to :class:`.sessionmaker` or</span>
<span class="sd">        the :class:`.Session` constructor.</span>

<span class="sd">        If a subtransaction is in effect (which occurs when begin() is called</span>
<span class="sd">        multiple times), the subtransaction will be closed, and the next call</span>
<span class="sd">        to ``commit()`` will operate on the enclosing transaction.</span>

<span class="sd">        When using the :class:`.Session` in its default mode of</span>
<span class="sd">        ``autocommit=False``, a new transaction will</span>
<span class="sd">        be begun immediately after the commit, but note that the newly begun</span>
<span class="sd">        transaction does *not* use any connection resources until the first</span>
<span class="sd">        SQL is actually emitted.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_committing`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;No transaction is begun.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare the current transaction in progress for two phase commit.</span>

<span class="sd">        If no transaction is in progress, this method raises an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError`.</span>

<span class="sd">        Only root transactions of two phase sessions can be prepared. If the</span>
<span class="sd">        current transaction is not such, an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;No transaction is begun.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">clause</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">close_with_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a :class:`.Connection` object corresponding to this</span>
<span class="sd">        :class:`.Session` object&#39;s transactional state.</span>

<span class="sd">        If this :class:`.Session` is configured with ``autocommit=False``,</span>
<span class="sd">        either the :class:`.Connection` corresponding to the current</span>
<span class="sd">        transaction is returned, or if no transaction is in progress, a new</span>
<span class="sd">        one is begun and the :class:`.Connection` returned (note that no</span>
<span class="sd">        transactional state is established with the DBAPI until the first</span>
<span class="sd">        SQL statement is emitted).</span>

<span class="sd">        Alternatively, if this :class:`.Session` is configured with</span>
<span class="sd">        ``autocommit=True``, an ad-hoc :class:`.Connection` is returned</span>
<span class="sd">        using :meth:`.Engine.connect` on the underlying</span>
<span class="sd">        :class:`.Engine`.</span>

<span class="sd">        Ambiguity in multi-bind or unbound :class:`.Session` objects can be</span>
<span class="sd">        resolved through any of the optional keyword arguments.   This</span>
<span class="sd">        ultimately makes usage of the :meth:`.get_bind` method for resolution.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          Optional :class:`.Engine` to be used as the bind.  If</span>
<span class="sd">          this engine is already involved in an ongoing transaction,</span>
<span class="sd">          that connection will be used.  This argument takes precedence</span>
<span class="sd">          over ``mapper``, ``clause``.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` mapped class, used to identify</span>
<span class="sd">          the appropriate bind.  This argument takes precedence over</span>
<span class="sd">          ``clause``.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,</span>
<span class="sd">            :func:`~.sql.expression.text`,</span>
<span class="sd">            etc.) which will be used to locate a bind, if a bind</span>
<span class="sd">            cannot otherwise be identified.</span>

<span class="sd">        :param close_with_result: Passed to :meth:`.Engine.connect`,</span>
<span class="sd">          indicating the :class:`.Connection` should be considered</span>
<span class="sd">          &quot;single use&quot;, automatically closing when the first result set is</span>
<span class="sd">          closed.  This flag only has an effect if this :class:`.Session` is</span>
<span class="sd">          configured with ``autocommit=True`` and does not already have a</span>
<span class="sd">          transaction in progress.</span>

<span class="sd">        :param execution_options: a dictionary of execution options that will</span>
<span class="sd">         be passed to :meth:`.Connection.execution_options`, **when the</span>
<span class="sd">         connection is first procured only**.   If the connection is already</span>
<span class="sd">         present within the :class:`.Session`, a warning is emitted and</span>
<span class="sd">         the arguments are ignored.</span>

<span class="sd">         .. versionadded:: 0.9.9</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`session_transaction_isolation`</span>

<span class="sd">        :param \**kw:</span>
<span class="sd">          Additional keyword arguments are sent to :meth:`get_bind()`,</span>
<span class="sd">          allowing additional arguments to be passed to custom</span>
<span class="sd">          implementations of :meth:`get_bind`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
            <span class="n">bind</span><span class="p">,</span>
            <span class="n">close_with_result</span><span class="o">=</span><span class="n">close_with_result</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
                <span class="n">engine</span><span class="p">,</span> <span class="n">execution_options</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">_contextual_connect</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Execute a SQL expression construct or string statement within</span>
<span class="sd">        the current transaction.</span>

<span class="sd">        Returns a :class:`.ResultProxy` representing</span>
<span class="sd">        results of the statement execution, in the same manner as that of an</span>
<span class="sd">        :class:`.Engine` or</span>
<span class="sd">        :class:`.Connection`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                        user_table.select().where(user_table.c.id == 5)</span>
<span class="sd">                    )</span>

<span class="sd">        :meth:`~.Session.execute` accepts any executable clause construct,</span>
<span class="sd">        such as :func:`~.sql.expression.select`,</span>
<span class="sd">        :func:`~.sql.expression.insert`,</span>
<span class="sd">        :func:`~.sql.expression.update`,</span>
<span class="sd">        :func:`~.sql.expression.delete`, and</span>
<span class="sd">        :func:`~.sql.expression.text`.  Plain SQL strings can be passed</span>
<span class="sd">        as well, which in the case of :meth:`.Session.execute` only</span>
<span class="sd">        will be interpreted the same as if it were passed via a</span>
<span class="sd">        :func:`~.expression.text` construct.  That is, the following usage::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                        &quot;SELECT * FROM user WHERE id=:param&quot;,</span>
<span class="sd">                        {&quot;param&quot;:5}</span>
<span class="sd">                    )</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            from sqlalchemy import text</span>
<span class="sd">            result = session.execute(</span>
<span class="sd">                        text(&quot;SELECT * FROM user WHERE id=:param&quot;),</span>
<span class="sd">                        {&quot;param&quot;:5}</span>
<span class="sd">                    )</span>

<span class="sd">        The second positional argument to :meth:`.Session.execute` is an</span>
<span class="sd">        optional parameter set.  Similar to that of</span>
<span class="sd">        :meth:`.Connection.execute`, whether this is passed as a single</span>
<span class="sd">        dictionary, or a list of dictionaries, determines whether the DBAPI</span>
<span class="sd">        cursor&#39;s ``execute()`` or ``executemany()`` is used to execute the</span>
<span class="sd">        statement.   An INSERT construct may be invoked for a single row::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                users.insert(), {&quot;id&quot;: 7, &quot;name&quot;: &quot;somename&quot;})</span>

<span class="sd">        or for multiple rows::</span>

<span class="sd">            result = session.execute(users.insert(), [</span>
<span class="sd">                                    {&quot;id&quot;: 7, &quot;name&quot;: &quot;somename7&quot;},</span>
<span class="sd">                                    {&quot;id&quot;: 8, &quot;name&quot;: &quot;somename8&quot;},</span>
<span class="sd">                                    {&quot;id&quot;: 9, &quot;name&quot;: &quot;somename9&quot;}</span>
<span class="sd">                                ])</span>

<span class="sd">        The statement is executed within the current transactional context of</span>
<span class="sd">        this :class:`.Session`.   The :class:`.Connection` which is used</span>
<span class="sd">        to execute the statement can also be acquired directly by</span>
<span class="sd">        calling the :meth:`.Session.connection` method.  Both methods use</span>
<span class="sd">        a rule-based resolution scheme in order to determine the</span>
<span class="sd">        :class:`.Connection`, which in the average case is derived directly</span>
<span class="sd">        from the &quot;bind&quot; of the :class:`.Session` itself, and in other cases</span>
<span class="sd">        can be based on the :func:`.mapper`</span>
<span class="sd">        and :class:`.Table` objects passed to the method; see the</span>
<span class="sd">        documentation for :meth:`.Session.get_bind` for a full description of</span>
<span class="sd">        this scheme.</span>

<span class="sd">        The :meth:`.Session.execute` method does *not* invoke autoflush.</span>

<span class="sd">        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`</span>
<span class="sd">        method is returned with the &quot;close_with_result&quot; flag set to true;</span>
<span class="sd">        the significance of this flag is that if this :class:`.Session` is</span>
<span class="sd">        autocommitting and does not have a transaction-dedicated</span>
<span class="sd">        :class:`.Connection` available, a temporary :class:`.Connection` is</span>
<span class="sd">        established for the statement execution, which is closed (meaning,</span>
<span class="sd">        returned to the connection pool) when the :class:`.ResultProxy` has</span>
<span class="sd">        consumed all available data. This applies *only* when the</span>
<span class="sd">        :class:`.Session` is configured with autocommit=True and no</span>
<span class="sd">        transaction has been started.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            An executable statement (i.e. an :class:`.Executable` expression</span>
<span class="sd">            such as :func:`.expression.select`) or string SQL statement</span>
<span class="sd">            to be executed.</span>

<span class="sd">        :param params:</span>
<span class="sd">            Optional dictionary, or list of dictionaries, containing</span>
<span class="sd">            bound parameter values.   If a single dictionary, single-row</span>
<span class="sd">            execution occurs; if a list of dictionaries, an</span>
<span class="sd">            &quot;executemany&quot; will be invoked.  The keys in each dictionary</span>
<span class="sd">            must correspond to parameter names present in the statement.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` or mapped class, used to identify</span>
<span class="sd">          the appropriate bind.  This argument takes precedence over</span>
<span class="sd">          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`</span>
<span class="sd">          for more details.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          Optional :class:`.Engine` to be used as the bind.  If</span>
<span class="sd">          this engine is already involved in an ongoing transaction,</span>
<span class="sd">          that connection will be used.  This argument takes</span>
<span class="sd">          precedence over ``mapper`` and ``clause`` when locating</span>
<span class="sd">          a bind.</span>

<span class="sd">        :param \**kw:</span>
<span class="sd">          Additional keyword arguments are sent to :meth:`.Session.get_bind()`</span>
<span class="sd">          to allow extensibility of &quot;bind&quot; schemes.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL</span>
<span class="sd">            constructs.</span>

<span class="sd">            :ref:`connections_toplevel` - Further information on direct</span>
<span class="sd">            statement execution.</span>

<span class="sd">            :meth:`.Connection.execute` - core level statement execution</span>
<span class="sd">            method, which is :meth:`.Session.execute` ultimately uses</span>
<span class="sd">            in order to execute the statement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clause</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_literal_as_text</span><span class="p">(</span>
            <span class="n">clause</span><span class="p">,</span> <span class="n">allow_coercion_to_text</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">clause</span><span class="p">,</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`~.Session.execute` but return a scalar result.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this Session.</span>

<span class="sd">        This clears all items and ends any transaction in progress.</span>

<span class="sd">        If this session were created with ``autocommit=False``, a new</span>
<span class="sd">        transaction is immediately begun.  Note that this new transaction does</span>
<span class="sd">        not use any connection resources until they are first needed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this Session, using connection invalidation.</span>

<span class="sd">        This is a variant of :meth:`.Session.close` that will additionally</span>
<span class="sd">        ensure that the :meth:`.Connection.invalidate` method will be called</span>
<span class="sd">        on all :class:`.Connection` objects.  This can be called when</span>
<span class="sd">        the database is known to be in a state where the connections are</span>
<span class="sd">        no longer safe to be used.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            try:</span>
<span class="sd">                sess = Session()</span>
<span class="sd">                sess.add(User())</span>
<span class="sd">                sess.commit()</span>
<span class="sd">            except gevent.Timeout:</span>
<span class="sd">                sess.invalidate()</span>
<span class="sd">                raise</span>
<span class="sd">            except:</span>
<span class="sd">                sess.rollback()</span>
<span class="sd">                raise</span>

<span class="sd">        This clears all items and ends any transaction in progress.</span>

<span class="sd">        If this session were created with ``autocommit=False``, a new</span>
<span class="sd">        transaction is immediately begun.  Note that this new transaction does</span>
<span class="sd">        not use any connection resources until they are first needed.</span>

<span class="sd">        .. versionadded:: 0.9.9</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_close_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expunge_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">invalidate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expunge_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all object instances from this ``Session``.</span>

<span class="sd">        This is equivalent to calling ``expunge(obj)`` on all objects in this</span>
<span class="sd">        ``Session``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span><span class="n">all_states</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;Not an acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_selectable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">elif</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_mapper</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="o">.</span><span class="n">class_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
                <span class="k">for</span> <span class="n">selectable</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">_all_tables</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">selectable</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;Not an acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate a :class:`.Mapper` or arbitrary Python class with a</span>
<span class="sd">        &quot;bind&quot;, e.g. an :class:`.Engine` or :class:`.Connection`.</span>

<span class="sd">        The given entity is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        :param mapper: a :class:`.Mapper` object, or an instance of a mapped</span>
<span class="sd">         class, or any Python class that is the base of a set of mapped</span>
<span class="sd">         classes.</span>

<span class="sd">        :param bind: an :class:`.Engine` or :class:`.Connection` object.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_partitioning`</span>

<span class="sd">            :paramref:`.Session.binds`</span>

<span class="sd">            :meth:`.Session.bind_table`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate a :class:`.Table` with a &quot;bind&quot;, e.g. an :class:`.Engine`</span>
<span class="sd">        or :class:`.Connection`.</span>

<span class="sd">        The given :class:`.Table` is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        :param table: a :class:`.Table` object, which is typically the target</span>
<span class="sd">         of an ORM mapping, or is present within a selectable that is</span>
<span class="sd">         mapped.</span>

<span class="sd">        :param bind: an :class:`.Engine` or :class:`.Connection` object.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_partitioning`</span>

<span class="sd">            :paramref:`.Session.binds`</span>

<span class="sd">            :meth:`.Session.bind_mapper`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a &quot;bind&quot; to which this :class:`.Session` is bound.</span>

<span class="sd">        The &quot;bind&quot; is usually an instance of :class:`.Engine`,</span>
<span class="sd">        except in the case where the :class:`.Session` has been</span>
<span class="sd">        explicitly bound directly to a :class:`.Connection`.</span>

<span class="sd">        For a multiply-bound or unbound :class:`.Session`, the</span>
<span class="sd">        ``mapper`` or ``clause`` arguments are used to determine the</span>
<span class="sd">        appropriate bind to return.</span>

<span class="sd">        Note that the &quot;mapper&quot; argument is usually present</span>
<span class="sd">        when :meth:`.Session.get_bind` is called via an ORM</span>
<span class="sd">        operation such as a :meth:`.Session.query`, each</span>
<span class="sd">        individual INSERT/UPDATE/DELETE operation within a</span>
<span class="sd">        :meth:`.Session.flush`, call, etc.</span>

<span class="sd">        The order of resolution is:</span>

<span class="sd">        1. if mapper given and session.binds is present,</span>
<span class="sd">           locate a bind based first on the mapper in use, then</span>
<span class="sd">           on the mapped class in use, then on any base classes that are</span>
<span class="sd">           present in the ``__mro__`` of the mapped class, from more specific</span>
<span class="sd">           superclasses to more general.</span>
<span class="sd">        2. if clause given and session.binds is present,</span>
<span class="sd">           locate a bind based on :class:`.Table` objects</span>
<span class="sd">           found in the given clause present in session.binds.</span>
<span class="sd">        3. if session.bind is present, return that.</span>
<span class="sd">        4. if clause given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`.MetaData` ultimately</span>
<span class="sd">           associated with the clause.</span>
<span class="sd">        5. if mapper given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`.MetaData` ultimately</span>
<span class="sd">           associated with the :class:`.Table` or other</span>
<span class="sd">           selectable to which the mapper is mapped.</span>
<span class="sd">        6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError`</span>
<span class="sd">           is raised.</span>

<span class="sd">        Note that the :meth:`.Session.get_bind` method can be overridden on</span>
<span class="sd">        a user-defined subclass of :class:`.Session` to provide any kind</span>
<span class="sd">        of bind resolution scheme.  See the example at</span>
<span class="sd">        :ref:`session_custom_partitioning`.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` mapped class or instance of</span>
<span class="sd">          :class:`.Mapper`.   The bind can be derived from a :class:`.Mapper`</span>
<span class="sd">          first by consulting the &quot;binds&quot; map associated with this</span>
<span class="sd">          :class:`.Session`, and secondly by consulting the :class:`.MetaData`</span>
<span class="sd">          associated with the :class:`.Table` to which the :class:`.Mapper`</span>
<span class="sd">          is mapped for a bind.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,</span>
<span class="sd">            :func:`~.sql.expression.text`,</span>
<span class="sd">            etc.).  If the ``mapper`` argument is not present or could not</span>
<span class="sd">            produce a bind, the given expression construct will be searched</span>
<span class="sd">            for a bound element, typically a :class:`.Table` associated with</span>
<span class="sd">            bound :class:`.MetaData`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">             :ref:`session_partitioning`</span>

<span class="sd">             :paramref:`.Session.binds`</span>

<span class="sd">             :meth:`.Session.bind_mapper`</span>

<span class="sd">             :meth:`.Session.bind_table`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is not bound to a single Engine or &quot;</span>
                    <span class="s2">&quot;Connection, and no context was provided to locate &quot;</span>
                    <span class="s2">&quot;a binding.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mapper</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedClassError</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mapper</span><span class="p">:</span>
                <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">clause</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">persist_selectable</span>

            <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_tables</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">include_crud</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">clause</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clause</span><span class="o">.</span><span class="n">bind</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">and</span> <span class="n">mapper</span><span class="o">.</span><span class="n">persist_selectable</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="n">persist_selectable</span><span class="o">.</span><span class="n">bind</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mapper </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">mapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SQL expression&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
            <span class="s2">&quot;Could not locate a bind configured on </span><span class="si">%s</span><span class="s2"> or this Session&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query` object corresponding to this</span>
<span class="sd">        :class:`.Session`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">no_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a context manager that disables autoflush.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            with session.no_autoflush:</span>

<span class="sd">                some_object = SomeClass()</span>
<span class="sd">                session.add(some_object)</span>
<span class="sd">                # won&#39;t autoflush</span>
<span class="sd">                some_object.related_thing = session.query(SomeRelated).first()</span>

<span class="sd">        Operations that proceed within the ``with:`` block</span>
<span class="sd">        will not be subject to flushes occurring upon query</span>
<span class="sd">        access.  This is useful when initializing a series</span>
<span class="sd">        of objects which involve existing database queries,</span>
<span class="sd">        where the uncompleted object should not yet be flushed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="k">def</span> <span class="nf">_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">StatementError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># note we are reraising StatementError as opposed to</span>
                <span class="c1"># raising FlushError with &quot;chaining&quot; to remain compatible</span>
                <span class="c1"># with code that catches StatementError, IntegrityError,</span>
                <span class="c1"># etc.</span>
                <span class="n">e</span><span class="o">.</span><span class="n">add_detail</span><span class="p">(</span>
                    <span class="s2">&quot;raised as a result of Query-invoked autoflush; &quot;</span>
                    <span class="s2">&quot;consider using a session.no_autoflush block if this &quot;</span>
                    <span class="s2">&quot;flush is occurring prematurely&quot;</span>
                <span class="p">)</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">,</span>
        <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">with_for_update</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lockmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire and refresh the attributes on the given instance.</span>

<span class="sd">        A query will be issued to the database and all attributes will be</span>
<span class="sd">        refreshed with their current database value.</span>

<span class="sd">        Lazy-loaded relational attributes will remain lazily loaded, so that</span>
<span class="sd">        the instance-wide refresh operation will be followed immediately by</span>
<span class="sd">        the lazy load of that attribute.</span>

<span class="sd">        Eagerly-loaded relational attributes will eagerly load within the</span>
<span class="sd">        single refresh operation.</span>

<span class="sd">        Note that a highly isolated transaction will return the same values as</span>
<span class="sd">        were previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction - usage of</span>
<span class="sd">        :meth:`~Session.refresh` usually only makes sense if non-ORM SQL</span>
<span class="sd">        statement were emitted in the ongoing transaction, or if autocommit</span>
<span class="sd">        mode is turned on.</span>

<span class="sd">        :param attribute_names: optional.  An iterable collection of</span>
<span class="sd">          string attribute names indicating a subset of attributes to</span>
<span class="sd">          be refreshed.</span>

<span class="sd">        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE</span>
<span class="sd">          should be used, or may be a dictionary containing flags to</span>
<span class="sd">          indicate a more specific set of FOR UPDATE flags for the SELECT;</span>
<span class="sd">          flags should match the parameters of :meth:`.Query.with_for_update`.</span>
<span class="sd">          Supersedes the :paramref:`.Session.refresh.lockmode` parameter.</span>

<span class="sd">          .. versionadded:: 1.2</span>

<span class="sd">        :param lockmode: Passed to the :class:`~sqlalchemy.orm.query.Query`</span>
<span class="sd">          as used by :meth:`~sqlalchemy.orm.query.Query.with_lockmode`.</span>
<span class="sd">          Superseded by :paramref:`.Session.refresh.with_for_update`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.expire_all`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_for_update</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;with_for_update should be the boolean value &quot;</span>
                <span class="s2">&quot;True, or a dictionary with options.  &quot;</span>
                <span class="s2">&quot;A blank dictionary is ambiguous.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">lockmode</span><span class="p">:</span>
            <span class="n">with_for_update</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">LockmodeArg</span><span class="o">.</span><span class="n">parse_legacy_query</span><span class="p">(</span><span class="n">lockmode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">with_for_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_for_update</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">with_for_update</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">LockmodeArg</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">with_for_update</span><span class="p">:</span>
                <span class="n">with_for_update</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">LockmodeArg</span><span class="p">(</span><span class="o">**</span><span class="n">with_for_update</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">with_for_update</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">loading</span><span class="o">.</span><span class="n">load_on_ident</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)),</span>
                <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
                <span class="n">refresh_state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span>
                <span class="n">with_for_update</span><span class="o">=</span><span class="n">with_for_update</span><span class="p">,</span>
                <span class="n">only_load_props</span><span class="o">=</span><span class="n">attribute_names</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Could not refresh instance &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">instance_str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">expire_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expires all persistent instances within this Session.</span>

<span class="sd">        When any attributes on a persistent instance is next accessed,</span>
<span class="sd">        a query will be issued using the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire individual objects and individual attributes</span>
<span class="sd">        on those objects, use :meth:`Session.expire`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire_all` should not be needed when</span>
<span class="sd">        autocommit is ``False``, assuming the transaction is isolated.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire the attributes on an instance.</span>

<span class="sd">        Marks the attributes of an instance as out of date. When an expired</span>
<span class="sd">        attribute is next accessed, a query will be issued to the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire all objects in the :class:`.Session` simultaneously,</span>
<span class="sd">        use :meth:`Session.expire_all`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire` only makes sense for the specific</span>
<span class="sd">        case that a non-ORM SQL statement was emitted in the current</span>
<span class="sd">        transaction.</span>

<span class="sd">        :param instance: The instance to be refreshed.</span>
<span class="sd">        :param attribute_names: optional list of string attribute names</span>
<span class="sd">          indicating a subset of attributes to be expired.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expire_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_persistent</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attribute_names</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pre-fetch the full cascade since the expire is going to</span>
            <span class="c1"># remove associations</span>
            <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;refresh-expire&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_expire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire a state if persistent, else expunge if pending&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;0.7&quot;</span><span class="p">,</span>
        <span class="s2">&quot;The :meth:`.Session.prune` method is deprecated along with &quot;</span>
        <span class="s2">&quot;:paramref:`.Session.weak_identity_map`.  This method will be &quot;</span>
        <span class="s2">&quot;removed in a future release.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove unreferenced instances cached in the identity map.</span>

<span class="sd">        Note that this method is only meaningful if &quot;weak_identity_map&quot; is set</span>
<span class="sd">        to False.  The default weak identity map is self-pruning.</span>

<span class="sd">        Removes any object in this Session&#39;s identity map that is not</span>
<span class="sd">        referenced in user code, modified, new or scheduled for deletion.</span>
<span class="sd">        Returns the number of objects pruned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">expunge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the `instance` from this ``Session``.</span>

<span class="sd">        This will free all internal references to the instance.  Cascading</span>
<span class="sd">        will be applied according to the *expunge* cascade rule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> is not present in this Session&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;expunge&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">st_</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_expunge_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">to_transient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
                <span class="c1"># state is &quot;detached&quot; from being deleted, but still present</span>
                <span class="c1"># in the transaction snapshot</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">to_transient</span><span class="o">=</span><span class="n">to_transient</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register all persistent objects from a flush.</span>

<span class="sd">        This is used both for pending objects moving to the persistent</span>
<span class="sd">        state as well as already persistent objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pending_to_persistent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">pending_to_persistent</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># prevent against last minute dereferences of the object</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">instance_key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span>
                    <span class="ow">or</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                        <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> has a NULL identity key.  If this is an &quot;</span>
                        <span class="s2">&quot;auto-generated value, check that the database table &quot;</span>
                        <span class="s2">&quot;allows generation of new primary key values, and &quot;</span>
                        <span class="s2">&quot;that the mapped Column object is configured to &quot;</span>
                        <span class="s2">&quot;expect these generated values.  Ensure also that &quot;</span>
                        <span class="s2">&quot;this flush() is not occurring at an inappropriate &quot;</span>
                        <span class="s2">&quot;time, such as within a load() event.&quot;</span>
                        <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>
                <span class="k">elif</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">!=</span> <span class="n">instance_key</span><span class="p">:</span>
                    <span class="c1"># primary key switch. use safe_discard() in case another</span>
                    <span class="c1"># state has already replaced this one in the identity</span>
                    <span class="c1"># map (see test/orm/test_naturalpks.py ReversePKsTest)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">orig_key</span><span class="p">,</span>
                        <span class="n">instance_key</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>

                <span class="c1"># there can be an existing state in the identity map</span>
                <span class="c1"># that is replaced when the primary keys of two instances</span>
                <span class="c1"># are swapped; see test/orm/test_naturalpks.py -&gt; test_reverse</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
            <span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_altered</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pending_to_persistent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
                <span class="n">pending_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">())</span>

        <span class="c1"># remove from new last, might be the last strong ref</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_altered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_dirty</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_remove_newly_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="n">persistent_to_deleted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">persistent_to_deleted</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">persistent_to_deleted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># get a strong reference before we pop out of</span>
                <span class="c1"># self._deleted</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># can&#39;t call state._detach() here, because this state</span>
            <span class="c1"># is still in the transaction snapshot and needs to be</span>
            <span class="c1"># tracked as part of that</span>
            <span class="k">if</span> <span class="n">persistent_to_deleted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">persistent_to_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Place an object in the ``Session``.</span>

<span class="sd">        Its state will be persisted to the database on the next flush</span>
<span class="sd">        operation.</span>

<span class="sd">        Repeated calls to ``add()`` will be ignored. The opposite of ``add()``</span>
<span class="sd">        is ``expunge()``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_warn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the given collection of instances to this ``Session``.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add_all()&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
            <span class="s2">&quot;save-update&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">halt_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark an instance as deleted.</span>

<span class="sd">        The database delete operation occurs upon ``flush()``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.delete()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_impl</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delete_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="c1"># grab the cascades before adding the item to the deleted list</span>
            <span class="c1"># so that autoflush does not delete the item</span>
            <span class="c1"># the strong reference to the instance itself is significant here</span>
            <span class="n">cascade_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascade_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the state of a given instance into a corresponding instance</span>
<span class="sd">        within this :class:`.Session`.</span>

<span class="sd">        :meth:`.Session.merge` examines the primary key attributes of the</span>
<span class="sd">        source instance, and attempts to reconcile it with an instance of the</span>
<span class="sd">        same primary key in the session.   If not found locally, it attempts</span>
<span class="sd">        to load the object from the database based on primary key, and if</span>
<span class="sd">        none can be located, creates a new instance.  The state of each</span>
<span class="sd">        attribute on the source instance is then copied to the target</span>
<span class="sd">        instance.  The resulting target instance is then returned by the</span>
<span class="sd">        method; the original source instance is left unmodified, and</span>
<span class="sd">        un-associated with the :class:`.Session` if not already.</span>

<span class="sd">        This operation cascades to associated instances if the association is</span>
<span class="sd">        mapped with ``cascade=&quot;merge&quot;``.</span>

<span class="sd">        See :ref:`unitofwork_merging` for a detailed discussion of merging.</span>

<span class="sd">        .. versionchanged:: 1.1 - :meth:`.Session.merge` will now reconcile</span>
<span class="sd">           pending objects with overlapping primary keys in the same way</span>
<span class="sd">           as persistent.  See :ref:`change_3601` for discussion.</span>

<span class="sd">        :param instance: Instance to be merged.</span>
<span class="sd">        :param load: Boolean, when False, :meth:`.merge` switches into</span>
<span class="sd">         a &quot;high performance&quot; mode which causes it to forego emitting history</span>
<span class="sd">         events as well as all database access.  This flag is used for</span>
<span class="sd">         cases such as transferring graphs of objects into a :class:`.Session`</span>
<span class="sd">         from a second level cache, or to transfer just-loaded objects</span>
<span class="sd">         into the :class:`.Session` owned by a worker thread or process</span>
<span class="sd">         without re-querying the database.</span>

<span class="sd">         The ``load=False`` use case adds the caveat that the given</span>
<span class="sd">         object has to be in a &quot;clean&quot; state, that is, has no pending changes</span>
<span class="sd">         to be flushed - even if the incoming object is detached from any</span>
<span class="sd">         :class:`.Session`.   This is so that when</span>
<span class="sd">         the merge operation populates local attributes and</span>
<span class="sd">         cascades to related objects and</span>
<span class="sd">         collections, the values can be &quot;stamped&quot; onto the</span>
<span class="sd">         target object as is, without generating any history or attribute</span>
<span class="sd">         events, and without the need to reconcile the incoming data with</span>
<span class="sd">         any existing related objects or collections that might not</span>
<span class="sd">         be loaded.  The resulting objects from ``load=False`` are always</span>
<span class="sd">         produced as &quot;clean&quot;, so it is only appropriate that the given objects</span>
<span class="sd">         should be &quot;clean&quot; as well, else this suggests a mis-use of the</span>
<span class="sd">         method.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.make_transient_to_detached` - provides for an alternative</span>
<span class="sd">            means of &quot;merging&quot; a single object into the :class:`.Session`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.merge()&quot;</span><span class="p">)</span>

        <span class="n">_recursive</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_resolve_conflict_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># flush current contents if we expect to load data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>

        <span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>  <span class="c1"># verify mapped</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">load</span><span class="o">=</span><span class="n">load</span><span class="p">,</span>
                <span class="n">_recursive</span><span class="o">=</span><span class="n">_recursive</span><span class="p">,</span>
                <span class="n">_resolve_conflict_map</span><span class="o">=</span><span class="n">_resolve_conflict_map</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">,</span>
        <span class="n">state_dict</span><span class="p">,</span>
        <span class="n">load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_recursive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">_resolve_conflict_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">_recursive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                    <span class="s2">&quot;objects transient (i.e. unpersisted) objects.  flush() &quot;</span>
                    <span class="s2">&quot;all changes on mapped instances before merging with &quot;</span>
                    <span class="s2">&quot;load=False.&quot;</span>
                <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">key_is_persistent</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">NEVER_SET</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_is_persistent</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># object was GC&#39;ed right as we checked for it</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">merged</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key_is_persistent</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_resolve_conflict_map</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">_resolve_conflict_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                        <span class="s2">&quot;objects marked as &#39;dirty&#39;.  flush() all changes on &quot;</span>
                        <span class="s2">&quot;mapped instances before merging with load=False.&quot;</span>
                    <span class="p">)</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
                <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                <span class="n">merged_state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
                <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">key_is_persistent</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">merged</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>

        <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>
        <span class="n">_resolve_conflict_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>

        <span class="c1"># check that we didn&#39;t just pull the exact same</span>
        <span class="c1"># state out.</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">merged_state</span><span class="p">:</span>
            <span class="c1"># version check if applicable</span>
            <span class="k">if</span> <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">existing_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">state_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">merged_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">merged_state</span><span class="p">,</span>
                    <span class="n">merged_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">existing_version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span>
                    <span class="ow">and</span> <span class="n">merged_version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span>
                    <span class="ow">and</span> <span class="n">existing_version</span> <span class="o">!=</span> <span class="n">merged_version</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">StaleDataError</span><span class="p">(</span>
                        <span class="s2">&quot;Version id &#39;</span><span class="si">%s</span><span class="s2">&#39; on merged state </span><span class="si">%s</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;does not match existing version &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                        <span class="s2">&quot;Leave the version attribute unset when &quot;</span>
                        <span class="s2">&quot;merging to update the most recent version.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">existing_version</span><span class="p">,</span>
                            <span class="n">state_str</span><span class="p">(</span><span class="n">merged_state</span><span class="p">),</span>
                            <span class="n">merged_version</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_path</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_options</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_options</span>

            <span class="c1"># since we are copying load_options, we need to copy</span>
            <span class="c1"># the callables_ that would have been generated by those</span>
            <span class="c1"># load_options.</span>
            <span class="c1"># assumes that the callables we put in state.callables_</span>
            <span class="c1"># are not instance-specific (which they should not be)</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">_copy_callables</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">iterate_properties</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">state_dict</span><span class="p">,</span>
                    <span class="n">merged_state</span><span class="p">,</span>
                    <span class="n">merged_dict</span><span class="p">,</span>
                    <span class="n">load</span><span class="p">,</span>
                    <span class="n">_recursive</span><span class="p">,</span>
                    <span class="n">_resolve_conflict_map</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># remove any history</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">merged_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_instance</span><span class="p">:</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">merged_state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span>

    <span class="k">def</span> <span class="nf">_validate_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persistent within this Session&quot;</span>
                <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; already has an identity - &quot;</span>
                <span class="s2">&quot;it can&#39;t be registered as pending&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="n">state</span><span class="o">.</span><span class="n">insert_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">revert_deletion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">revert_deletion</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">_attached</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; has been deleted.  &quot;</span>
                    <span class="s2">&quot;Use the make_transient() &quot;</span>
                    <span class="s2">&quot;function to send this object back &quot;</span>
                    <span class="s2">&quot;to the transient state.&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>

        <span class="c1"># check for late gc</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">revert_deletion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">revert_deletion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">deleted_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enable_relationship_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate an object with this :class:`.Session` for related</span>
<span class="sd">        object loading.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            :meth:`.enable_relationship_loading` exists to serve special</span>
<span class="sd">            use cases and is not recommended for general use.</span>

<span class="sd">        Accesses of attributes mapped with :func:`.relationship`</span>
<span class="sd">        will attempt to load a value from the database using this</span>
<span class="sd">        :class:`.Session` as the source of connectivity.  The values</span>
<span class="sd">        will be loaded based on foreign key and primary key values</span>
<span class="sd">        present on this object - if not present, then those relationships</span>
<span class="sd">        will be unavailable.</span>

<span class="sd">        The object will be attached to this session, but will</span>
<span class="sd">        **not** participate in any persistence operations; its state</span>
<span class="sd">        for almost all purposes will remain either &quot;transient&quot; or</span>
<span class="sd">        &quot;detached&quot;, except for the case of relationship loading.</span>

<span class="sd">        Also note that backrefs will often not work as expected.</span>
<span class="sd">        Altering a relationship-bound attribute on the target object</span>
<span class="sd">        may not fire off a backref event, if the effective value</span>
<span class="sd">        is what was already loaded from a foreign-key-holding value.</span>

<span class="sd">        The :meth:`.Session.enable_relationship_loading` method is</span>
<span class="sd">        similar to the ``load_on_pending`` flag on :func:`.relationship`.</span>
<span class="sd">        Unlike that flag, :meth:`.Session.enable_relationship_loading` allows</span>
<span class="sd">        an object to remain transient while still being able to load</span>
<span class="sd">        related items.</span>

<span class="sd">        To make a transient object associated with a :class:`.Session`</span>
<span class="sd">        via :meth:`.Session.enable_relationship_loading` pending, add</span>
<span class="sd">        it to the :class:`.Session` using :meth:`.Session.add` normally.</span>
<span class="sd">        If the object instead represents an existing identity in the database,</span>
<span class="sd">        it should be merged using :meth:`.Session.merge`.</span>

<span class="sd">        :meth:`.Session.enable_relationship_loading` does not improve</span>
<span class="sd">        behavior when the ORM is used normally - object references should be</span>
<span class="sd">        constructed at the object level, not at the foreign key level, so</span>
<span class="sd">        that they are present in an ordinary way before flush()</span>
<span class="sd">        proceeds.  This method is not intended for general use.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            ``load_on_pending`` at :func:`.relationship` - this flag</span>
<span class="sd">            allows per-relationship loading of many-to-ones on items that</span>
<span class="sd">            are pending.</span>

<span class="sd">            :func:`.make_transient_to_detached` - allows for an object to</span>
<span class="sd">            be added to a :class:`.Session` without SQL emitted, which then</span>
<span class="sd">            will unexpire attributes on access.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">_load_pending</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; is already attached to session &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;(this is &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_after_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">detached_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">transient_to_pending</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the instance is associated with this session.</span>

<span class="sd">        The instance may be pending or persistent within the Session for a</span>
<span class="sd">        result of True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over all pending or persistent instances within this</span>
<span class="sd">        Session.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_contains_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all the object changes to the database.</span>

<span class="sd">        Writes out all pending object creations, deletions and modifications</span>
<span class="sd">        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are</span>
<span class="sd">        automatically ordered by the Session&#39;s unit of work dependency</span>
<span class="sd">        solver.</span>

<span class="sd">        Database operations will be issued in the current transactional</span>
<span class="sd">        context and do not affect the state of the transaction, unless an</span>
<span class="sd">        error occurs, in which case the entire transaction is rolled back.</span>
<span class="sd">        You may flush() as often as you like within a transaction to move</span>
<span class="sd">        changes from Python to the database&#39;s transaction buffer.</span>

<span class="sd">        For ``autocommit`` Sessions with no active manual transaction, flush()</span>
<span class="sd">        will create a transaction on the fly that surrounds the entire set of</span>
<span class="sd">        operations into the flush.</span>

<span class="sd">        :param objects: Optional; restricts the flush operation to operate</span>
<span class="sd">          only on elements that are in the given collection.</span>

<span class="sd">          This feature is for an extremely narrow set of use cases where</span>
<span class="sd">          particular objects may need to be operated upon before the</span>
<span class="sd">          full flush() occurs.  It is not intended for general use.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Session is already flushing&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_flush_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Usage of the &#39;</span><span class="si">%s</span><span class="s2">&#39; operation is not currently supported &quot;</span>
            <span class="s2">&quot;within the execution stage of the flush process. &quot;</span>
            <span class="s2">&quot;Results may not be consistent.  Consider using alternative &quot;</span>
            <span class="s2">&quot;event listeners or connection-level operations instead.&quot;</span> <span class="o">%</span> <span class="n">method</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">check_modified</span><span class="p">()</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="n">flush_context</span> <span class="o">=</span> <span class="n">UOWTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">objects</span><span class="p">)</span>
            <span class="c1"># re-establish &quot;dirty states&quot; in case the listeners</span>
            <span class="c1"># added</span>
            <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>

        <span class="n">deleted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>

        <span class="n">dirty</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="c1"># create the set of all objects we want to operate upon</span>
        <span class="k">if</span> <span class="n">objects</span><span class="p">:</span>
            <span class="c1"># specific list passed in</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="n">objset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># store objects whose fate has been decided</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># put all saves/updates into the flush context.  detect top-level</span>
        <span class="c1"># orphans and throw them into deleted.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">is_orphan</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">_is_orphan</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="n">is_persistent_orphan</span> <span class="o">=</span> <span class="n">is_orphan</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">has_identity</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">is_orphan</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_persistent_orphan</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_reg</span> <span class="o">=</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span>
                    <span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="n">is_persistent_orphan</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">_reg</span><span class="p">,</span> <span class="s2">&quot;Failed to add object to the flush context!&quot;</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># put all remaining deletes into the flush context.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">_reg</span> <span class="o">=</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">_reg</span><span class="p">,</span> <span class="s2">&quot;Failed to add object to the flush context!&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">has_work</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">flush_context</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span>
            <span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">flush_context</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">flush_context</span><span class="o">.</span><span class="n">finalize_flush_changes</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">objects</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

                <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span>
                    <span class="p">],</span>
                    <span class="n">instance_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Attribute history events accumulated on </span><span class="si">%d</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;previously clean instances &quot;</span>
                    <span class="s2">&quot;within inner-flush event handlers have been &quot;</span>
                    <span class="s2">&quot;reset, and will not result in database updates. &quot;</span>
                    <span class="s2">&quot;Consider using set_committed_value() within &quot;</span>
                    <span class="s2">&quot;inner-flush event handlers to avoid this warning.&quot;</span> <span class="o">%</span> <span class="n">len_</span>
                <span class="p">)</span>

            <span class="c1"># useful assertions:</span>
            <span class="c1"># if not objects:</span>
            <span class="c1">#    assert not self.identity_map._modified</span>
            <span class="c1"># else:</span>
            <span class="c1">#    assert self.identity_map._modified == \</span>
            <span class="c1">#            self.identity_map._modified.difference(objects)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush_postexec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_save_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">objects</span><span class="p">,</span>
        <span class="n">return_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">update_changed_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">preserve_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk save of the given list of objects.</span>

<span class="sd">        The bulk save feature allows mapped objects to be used as the</span>
<span class="sd">        source of simple INSERT and UPDATE operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations; the extraction of data from the objects is also performed</span>
<span class="sd">        using a lower-latency process that ignores whether or not attributes</span>
<span class="sd">        have actually been modified in the case of UPDATEs, and also ignores</span>
<span class="sd">        SQL expressions.</span>

<span class="sd">        The objects as given are not added to the session and no additional</span>
<span class="sd">        state is established on them, unless the ``return_defaults`` flag</span>
<span class="sd">        is also set, in which case primary key attributes and server-side</span>
<span class="sd">        default values will be populated.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk save feature allows for a lower-latency INSERT/UPDATE</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            INSERT/UPDATES of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param objects: a list of mapped object instances.  The mapped</span>
<span class="sd">         objects are persisted as is, and are **not** associated with the</span>
<span class="sd">         :class:`.Session` afterwards.</span>

<span class="sd">         For each object, whether the object is sent as an INSERT or an</span>
<span class="sd">         UPDATE is dependent on the same rules used by the :class:`.Session`</span>
<span class="sd">         in traditional operation; if the object has the</span>
<span class="sd">         :attr:`.InstanceState.key`</span>
<span class="sd">         attribute set, then the object is assumed to be &quot;detached&quot; and</span>
<span class="sd">         will result in an UPDATE.  Otherwise, an INSERT is used.</span>

<span class="sd">         In the case of an UPDATE, statements are grouped based on which</span>
<span class="sd">         attributes have changed, and are thus to be the subject of each</span>
<span class="sd">         SET clause.  If ``update_changed_only`` is False, then all</span>
<span class="sd">         attributes present within each object are applied to the UPDATE</span>
<span class="sd">         statement, which may help in allowing the statements to be grouped</span>
<span class="sd">         together into a larger executemany(), and will also reduce the</span>
<span class="sd">         overhead of checking history on attributes.</span>

<span class="sd">        :param return_defaults: when True, rows that are missing values which</span>
<span class="sd">         generate defaults, namely integer primary key defaults and sequences,</span>
<span class="sd">         will be inserted **one at a time**, so that the primary key value</span>
<span class="sd">         is available.  In particular this will allow joined-inheritance</span>
<span class="sd">         and other multi-table mappings to insert correctly without the need</span>
<span class="sd">         to provide primary key values ahead of time; however,</span>
<span class="sd">         :paramref:`.Session.bulk_save_objects.return_defaults` **greatly</span>
<span class="sd">         reduces the performance gains** of the method overall.</span>

<span class="sd">        :param update_changed_only: when True, UPDATE statements are rendered</span>
<span class="sd">         based on those attributes in each state that have logged changes.</span>
<span class="sd">         When False, all attributes present are rendered into the SET clause</span>
<span class="sd">         with the exception of primary key attributes.</span>

<span class="sd">        :param preserve_order: when True, the order of inserts and updates</span>
<span class="sd">         matches exactly the order in which the objects are given.   When</span>
<span class="sd">         False, common types of objects are grouped into inserts</span>
<span class="sd">         and updates, to allow for more batching opportunities.</span>

<span class="sd">         .. versionadded:: 1.3</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">obj_states</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_order</span><span class="p">:</span>
            <span class="n">obj_states</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">obj_states</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">isupdate</span><span class="p">),</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">obj_states</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
                <span class="n">mapper</span><span class="p">,</span>
                <span class="n">states</span><span class="p">,</span>
                <span class="n">isupdate</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="n">return_defaults</span><span class="p">,</span>
                <span class="n">update_changed_only</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_insert_mappings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="n">return_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">render_nulls</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk insert of the given list of mapping dictionaries.</span>

<span class="sd">        The bulk insert feature allows plain Python dictionaries to be used as</span>
<span class="sd">        the source of simple INSERT operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations.  Using dictionaries, there is no &quot;history&quot; or session</span>
<span class="sd">        state management features in use, reducing latency when inserting</span>
<span class="sd">        large numbers of simple rows.</span>

<span class="sd">        The values within the dictionaries as given are typically passed</span>
<span class="sd">        without modification into Core :meth:`.Insert` constructs, after</span>
<span class="sd">        organizing the values within them across the tables to which</span>
<span class="sd">        the given mapper is mapped.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk insert feature allows for a lower-latency INSERT</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            INSERT of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`.Mapper` object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a list of dictionaries, each one containing the state</span>
<span class="sd">         of the mapped row to be inserted, in terms of the attribute names</span>
<span class="sd">         on the mapped class.   If the mapping refers to multiple tables,</span>
<span class="sd">         such as a joined-inheritance mapping, each dictionary must contain</span>
<span class="sd">         all keys to be populated into all tables.</span>

<span class="sd">        :param return_defaults: when True, rows that are missing values which</span>
<span class="sd">         generate defaults, namely integer primary key defaults and sequences,</span>
<span class="sd">         will be inserted **one at a time**, so that the primary key value</span>
<span class="sd">         is available.  In particular this will allow joined-inheritance</span>
<span class="sd">         and other multi-table mappings to insert correctly without the need</span>
<span class="sd">         to provide primary</span>
<span class="sd">         key values ahead of time; however,</span>
<span class="sd">         :paramref:`.Session.bulk_insert_mappings.return_defaults`</span>
<span class="sd">         **greatly reduces the performance gains** of the method overall.</span>
<span class="sd">         If the rows</span>
<span class="sd">         to be inserted only refer to a single table, then there is no</span>
<span class="sd">         reason this flag should be set as the returned default information</span>
<span class="sd">         is not used.</span>

<span class="sd">        :param render_nulls: When True, a value of ``None`` will result</span>
<span class="sd">         in a NULL value being included in the INSERT statement, rather</span>
<span class="sd">         than the column being omitted from the INSERT.   This allows all</span>
<span class="sd">         the rows being INSERTed to have the identical set of columns which</span>
<span class="sd">         allows the full set of rows to be batched to the DBAPI.  Normally,</span>
<span class="sd">         each column-set that contains a different combination of NULL values</span>
<span class="sd">         than the previous row must omit a different series of columns from</span>
<span class="sd">         the rendered INSERT statement, which means it must be emitted as a</span>
<span class="sd">         separate statement.   By passing this flag, the full set of rows</span>
<span class="sd">         are guaranteed to be batchable into one batch; the cost however is</span>
<span class="sd">         that server-side defaults which are invoked by an omitted column will</span>
<span class="sd">         be skipped, so care must be taken to ensure that these are not</span>
<span class="sd">         necessary.</span>

<span class="sd">         .. warning::</span>

<span class="sd">            When this flag is set, **server side default SQL values will</span>
<span class="sd">            not be invoked** for those columns that are inserted as NULL;</span>
<span class="sd">            the NULL value will be sent explicitly.   Care must be taken</span>
<span class="sd">            to ensure that no server-side default functions need to be</span>
<span class="sd">            invoked for the operation as a whole.</span>

<span class="sd">         .. versionadded:: 1.1</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
            <span class="n">mapper</span><span class="p">,</span>
            <span class="n">mappings</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">return_defaults</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">render_nulls</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_update_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk update of the given list of mapping dictionaries.</span>

<span class="sd">        The bulk update feature allows plain Python dictionaries to be used as</span>
<span class="sd">        the source of simple UPDATE operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations.  Using dictionaries, there is no &quot;history&quot; or session</span>
<span class="sd">        state management features in use, reducing latency when updating</span>
<span class="sd">        large numbers of simple rows.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk update feature allows for a lower-latency UPDATE</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            UPDATES of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`.Mapper` object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a list of dictionaries, each one containing the state</span>
<span class="sd">         of the mapped row to be updated, in terms of the attribute names</span>
<span class="sd">         on the mapped class.   If the mapping refers to multiple tables,</span>
<span class="sd">         such as a joined-inheritance mapping, each dictionary may contain</span>
<span class="sd">         keys corresponding to all tables.   All those keys which are present</span>
<span class="sd">         and are not part of the primary key are applied to the SET clause</span>
<span class="sd">         of the UPDATE statement; the primary key values, which are required,</span>
<span class="sd">         are applied to the WHERE clause.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
            <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bulk_save_mappings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">,</span>
        <span class="n">mappings</span><span class="p">,</span>
        <span class="n">isupdate</span><span class="p">,</span>
        <span class="n">isstates</span><span class="p">,</span>
        <span class="n">return_defaults</span><span class="p">,</span>
        <span class="n">update_changed_only</span><span class="p">,</span>
        <span class="n">render_nulls</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_class_to_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isupdate</span><span class="p">:</span>
                <span class="n">persistence</span><span class="o">.</span><span class="n">_bulk_update</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span>
                    <span class="n">mappings</span><span class="p">,</span>
                    <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">isstates</span><span class="p">,</span>
                    <span class="n">update_changed_only</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">persistence</span><span class="o">.</span><span class="n">_bulk_insert</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span>
                    <span class="n">mappings</span><span class="p">,</span>
                    <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">isstates</span><span class="p">,</span>
                    <span class="n">return_defaults</span><span class="p">,</span>
                    <span class="n">render_nulls</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated_params</span><span class="p">(</span>
        <span class="n">passive</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;0.8&quot;</span><span class="p">,</span>
            <span class="s2">&quot;The :paramref:`.Session.is_modified.passive` flag is deprecated &quot;</span>
            <span class="s2">&quot;and will be removed in a future release.  The flag is no longer &quot;</span>
            <span class="s2">&quot;used and is ignored.&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">include_collections</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">passive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return ``True`` if the given instance has locally</span>
<span class="sd">        modified attributes.</span>

<span class="sd">        This method retrieves the history for each instrumented</span>
<span class="sd">        attribute on the instance and performs a comparison of the current</span>
<span class="sd">        value to its previously committed value, if any.</span>

<span class="sd">        It is in effect a more expensive and accurate</span>
<span class="sd">        version of checking for the given instance in the</span>
<span class="sd">        :attr:`.Session.dirty` collection; a full test for</span>
<span class="sd">        each attribute&#39;s net &quot;dirty&quot; status is performed.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            return session.is_modified(someobject)</span>

<span class="sd">        A few caveats to this method apply:</span>

<span class="sd">        * Instances present in the :attr:`.Session.dirty` collection may</span>
<span class="sd">          report ``False`` when tested with this method.  This is because</span>
<span class="sd">          the object may have received change events via attribute mutation,</span>
<span class="sd">          thus placing it in :attr:`.Session.dirty`, but ultimately the state</span>
<span class="sd">          is the same as that loaded from the database, resulting in no net</span>
<span class="sd">          change here.</span>
<span class="sd">        * Scalar attributes may not have recorded the previously set</span>
<span class="sd">          value when a new value was applied, if the attribute was not loaded,</span>
<span class="sd">          or was expired, at the time the new value was received - in these</span>
<span class="sd">          cases, the attribute is assumed to have a change, even if there is</span>
<span class="sd">          ultimately no net change against its database value. SQLAlchemy in</span>
<span class="sd">          most cases does not need the &quot;old&quot; value when a set event occurs, so</span>
<span class="sd">          it skips the expense of a SQL call if the old value isn&#39;t present,</span>
<span class="sd">          based on the assumption that an UPDATE of the scalar value is</span>
<span class="sd">          usually needed, and in those few cases where it isn&#39;t, is less</span>
<span class="sd">          expensive on average than issuing a defensive SELECT.</span>

<span class="sd">          The &quot;old&quot; value is fetched unconditionally upon set only if the</span>
<span class="sd">          attribute container has the ``active_history`` flag set to ``True``.</span>
<span class="sd">          This flag is set typically for primary key attributes and scalar</span>
<span class="sd">          object references that are not a simple many-to-one.  To set this</span>
<span class="sd">          flag for any arbitrary mapped column, use the ``active_history``</span>
<span class="sd">          argument with :func:`.column_property`.</span>

<span class="sd">        :param instance: mapped instance to be tested for pending changes.</span>
<span class="sd">        :param include_collections: Indicates if multivalued collections</span>
<span class="sd">         should be included in the operation.  Setting this to ``False`` is a</span>
<span class="sd">         way to detect only local-column based properties (i.e. scalar columns</span>
<span class="sd">         or many-to-one foreign keys) that would result in an UPDATE for this</span>
<span class="sd">         instance upon flush.</span>
<span class="sd">        :param passive: not used</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">object_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dict_</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">include_collections</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s2">&quot;get_collection&quot;</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s2">&quot;get_history&quot;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">unchanged</span><span class="p">,</span> <span class="n">deleted</span><span class="p">)</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span>
                <span class="n">state</span><span class="p">,</span> <span class="n">dict_</span><span class="p">,</span> <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">NO_CHANGE</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">added</span> <span class="ow">or</span> <span class="n">deleted</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this :class:`.Session` is in &quot;transaction mode&quot; and</span>
<span class="sd">        is not in &quot;partial rollback&quot; state.</span>

<span class="sd">        The :class:`.Session` in its default mode of ``autocommit=False``</span>
<span class="sd">        is essentially always in &quot;transaction mode&quot;, in that a</span>
<span class="sd">        :class:`.SessionTransaction` is associated with it as soon as</span>
<span class="sd">        it is instantiated.  This :class:`.SessionTransaction` is immediately</span>
<span class="sd">        replaced with a new one as soon as it is ended, due to a rollback,</span>
<span class="sd">        commit, or close operation.</span>

<span class="sd">        &quot;Transaction mode&quot; does *not* indicate whether</span>
<span class="sd">        or not actual database connection resources are in use;  the</span>
<span class="sd">        :class:`.SessionTransaction` object coordinates among zero or more</span>
<span class="sd">        actual database transactions, and starts out with none, accumulating</span>
<span class="sd">        individual DBAPI connections as different data sources are used</span>
<span class="sd">        within its scope.   The best way to track when a particular</span>
<span class="sd">        :class:`.Session` has actually begun to use DBAPI resources is to</span>
<span class="sd">        implement a listener using the :meth:`.SessionEvents.after_begin`</span>
<span class="sd">        method, which will deliver both the :class:`.Session` as well as the</span>
<span class="sd">        target :class:`.Connection` to a user-defined event listener.</span>

<span class="sd">        The &quot;partial rollback&quot; state refers to when an &quot;inner&quot; transaction,</span>
<span class="sd">        typically used during a flush, encounters an error and emits a</span>
<span class="sd">        rollback of the DBAPI connection.  At this point, the</span>
<span class="sd">        :class:`.Session` is in &quot;partial rollback&quot; and awaits for the user to</span>
<span class="sd">        call :meth:`.Session.rollback`, in order to close out the</span>
<span class="sd">        transaction stack.  It is in this &quot;partial rollback&quot; period that the</span>
<span class="sd">        :attr:`.is_active` flag returns False.  After the call to</span>
<span class="sd">        :meth:`.Session.rollback`, the :class:`.SessionTransaction` is</span>
<span class="sd">        replaced with a new one and :attr:`.is_active` returns ``True`` again.</span>

<span class="sd">        When a :class:`.Session` is used in ``autocommit=True`` mode, the</span>
<span class="sd">        :class:`.SessionTransaction` is only instantiated within the scope</span>
<span class="sd">        of a flush call, or when :meth:`.Session.begin` is called.  So</span>
<span class="sd">        :attr:`.is_active` will always be ``False`` outside of a flush or</span>
<span class="sd">        :meth:`.Session.begin` block in this mode, and will be ``True``</span>
<span class="sd">        within the :meth:`.Session.begin` block as long as it doesn&#39;t enter</span>
<span class="sd">        &quot;partial rollback&quot; state.</span>

<span class="sd">        From all the above, it follows that the only purpose to this flag is</span>
<span class="sd">        for application frameworks that wish to detect is a &quot;rollback&quot; is</span>
<span class="sd">        necessary within a generic error handling routine, for</span>
<span class="sd">        :class:`.Session` objects that would otherwise be in</span>
<span class="sd">        &quot;partial rollback&quot; mode.  In a typical integration case, this is also</span>
<span class="sd">        not necessary as it is standard practice to emit</span>
<span class="sd">        :meth:`.Session.rollback` unconditionally within the outermost</span>
<span class="sd">        exception catch.</span>

<span class="sd">        To track the transactional state of a :class:`.Session` fully,</span>
<span class="sd">        use event listeners, primarily the :meth:`.SessionEvents.after_begin`,</span>
<span class="sd">        :meth:`.SessionEvents.after_commit`,</span>
<span class="sd">        :meth:`.SessionEvents.after_rollback` and related events.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">is_active</span>

    <span class="n">identity_map</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;A mapping of object identities to objects themselves.</span>

<span class="sd">    Iterating through ``Session.identity_map.values()`` provides</span>
<span class="sd">    access to the full set of persistent objects (i.e., those</span>
<span class="sd">    that have row identity) currently in the session.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.identity_key` - helper function to produce the keys used</span>
<span class="sd">        in this dictionary.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dirty_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of all persistent states considered dirty.</span>

<span class="sd">        This method returns all states that were modified including</span>
<span class="sd">        those that were possibly deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_dirty_states</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of all persistent instances considered dirty.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            some_mapped_object in session.dirty</span>

<span class="sd">        Instances are considered dirty when they were modified but not</span>
<span class="sd">        deleted.</span>

<span class="sd">        Note that this &#39;dirty&#39; calculation is &#39;optimistic&#39;; most</span>
<span class="sd">        attribute-setting or collection modification operations will</span>
<span class="sd">        mark an instance as &#39;dirty&#39; and place it in this set, even if</span>
<span class="sd">        there is no net change to the attribute&#39;s value.  At flush</span>
<span class="sd">        time, the value of each attribute is compared to its</span>
<span class="sd">        previously saved value, and if there&#39;s no net change, no SQL</span>
<span class="sd">        operation will occur (this is a more expensive operation so</span>
<span class="sd">        it&#39;s only done at flush time).</span>

<span class="sd">        To check if an instance has actionable net changes to its</span>
<span class="sd">        attributes, use the :meth:`.Session.is_modified` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The set of all instances marked as &#39;deleted&#39; within this ``Session``&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The set of all instances marked as &#39;new&#39; within this ``Session``.&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


<span class="k">class</span> <span class="nc">sessionmaker</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A configurable :class:`.Session` factory.</span>

<span class="sd">    The :class:`.sessionmaker` factory generates new</span>
<span class="sd">    :class:`.Session` objects when called, creating them given</span>
<span class="sd">    the configurational arguments established here.</span>

<span class="sd">    e.g.::</span>

<span class="sd">        # global scope</span>
<span class="sd">        Session = sessionmaker(autoflush=False)</span>

<span class="sd">        # later, in a local scope, create and use a session:</span>
<span class="sd">        sess = Session()</span>

<span class="sd">    Any keyword arguments sent to the constructor itself will override the</span>
<span class="sd">    &quot;configured&quot; keywords::</span>

<span class="sd">        Session = sessionmaker()</span>

<span class="sd">        # bind an individual session to a connection</span>
<span class="sd">        sess = Session(bind=connection)</span>

<span class="sd">    The class also includes a method :meth:`.configure`, which can</span>
<span class="sd">    be used to specify additional keyword arguments to the factory, which</span>
<span class="sd">    will take effect for subsequent :class:`.Session` objects generated.</span>
<span class="sd">    This is usually used to associate one or more :class:`.Engine` objects</span>
<span class="sd">    with an existing :class:`.sessionmaker` factory before it is first</span>
<span class="sd">    used::</span>

<span class="sd">        # application starts</span>
<span class="sd">        Session = sessionmaker()</span>

<span class="sd">        # ... later</span>
<span class="sd">        engine = create_engine(&#39;sqlite:///foo.db&#39;)</span>
<span class="sd">        Session.configure(bind=engine)</span>

<span class="sd">        sess = Session()</span>

<span class="sd">    .. seealso:</span>

<span class="sd">        :ref:`session_getting` - introductory text on creating</span>
<span class="sd">        sessions using :class:`.sessionmaker`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">class_</span><span class="o">=</span><span class="n">Session</span><span class="p">,</span>
        <span class="n">autoflush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a new :class:`.sessionmaker`.</span>

<span class="sd">        All arguments here except for ``class_`` correspond to arguments</span>
<span class="sd">        accepted by :class:`.Session` directly.  See the</span>
<span class="sd">        :meth:`.Session.__init__` docstring for more details on parameters.</span>

<span class="sd">        :param bind: a :class:`.Engine` or other :class:`.Connectable` with</span>
<span class="sd">         which newly created :class:`.Session` objects will be associated.</span>
<span class="sd">        :param class_: class to use in order to create new :class:`.Session`</span>
<span class="sd">         objects.  Defaults to :class:`.Session`.</span>
<span class="sd">        :param autoflush: The autoflush setting to use with newly created</span>
<span class="sd">         :class:`.Session` objects.</span>
<span class="sd">        :param autocommit: The autocommit setting to use with newly created</span>
<span class="sd">         :class:`.Session` objects.</span>
<span class="sd">        :param expire_on_commit=True: the expire_on_commit setting to use</span>
<span class="sd">         with newly created :class:`.Session` objects.</span>
<span class="sd">        :param info: optional dictionary of information that will be available</span>
<span class="sd">         via :attr:`.Session.info`.  Note this dictionary is *updated*, not</span>
<span class="sd">         replaced, when the ``info`` parameter is specified to the specific</span>
<span class="sd">         :class:`.Session` construction operation.</span>

<span class="sd">         .. versionadded:: 0.9.0</span>

<span class="sd">        :param \**kw: all other keyword arguments are passed to the</span>
<span class="sd">         constructor of newly created :class:`.Session` objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;bind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;autoflush&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;autocommit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;expire_on_commit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>
        <span class="c1"># make our own subclass of the given class, so that</span>
        <span class="c1"># events can be associated with it specifically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">class_</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">local_kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a new :class:`.Session` object using the configuration</span>
<span class="sd">        established in this :class:`.sessionmaker`.</span>

<span class="sd">        In Python, the ``__call__`` method is invoked on an object when</span>
<span class="sd">        it is &quot;called&quot; in the same way as a function::</span>

<span class="sd">            Session = sessionmaker()</span>
<span class="sd">            session = Session()  # invokes sessionmaker.__call__()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;info&quot;</span> <span class="ow">and</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">local_kw</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
                <span class="n">local_kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="p">(</span><span class="o">**</span><span class="n">local_kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Re)configure the arguments for this sessionmaker.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            Session = sessionmaker()</span>

<span class="sd">            Session.configure(bind=create_engine(&#39;sqlite://&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(class_=</span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">close_all_sessions</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Close all sessions in memory.</span>

<span class="sd">    This function consults a global registry of all :class:`.Session` objects</span>
<span class="sd">    and calls :meth:`.Session.close` on them, which resets them to a clean</span>
<span class="sd">    state.</span>

<span class="sd">    This function is not for general use but may be useful for test suites</span>
<span class="sd">    within the teardown scheme.</span>

<span class="sd">    .. versionadded:: 1.3</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">sess</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">make_transient</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alter the state of the given instance so that it is :term:`transient`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        :func:`.make_transient` is a special-case function for</span>
<span class="sd">        advanced use cases only.</span>

<span class="sd">    The given mapped instance is assumed to be in the :term:`persistent` or</span>
<span class="sd">    :term:`detached` state.   The function will remove its association with any</span>
<span class="sd">    :class:`.Session` as well as its :attr:`.InstanceState.identity`. The</span>
<span class="sd">    effect is that the object will behave as though it were newly constructed,</span>
<span class="sd">    except retaining any attribute / collection values that were loaded at the</span>
<span class="sd">    time of the call.   The :attr:`.InstanceState.deleted` flag is also reset</span>
<span class="sd">    if this object had been deleted as a result of using</span>
<span class="sd">    :meth:`.Session.delete`.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        :func:`.make_transient` does **not** &quot;unexpire&quot; or otherwise eagerly</span>
<span class="sd">        load ORM-mapped attributes that are not currently loaded at the time</span>
<span class="sd">        the function is called.   This includes attributes which:</span>

<span class="sd">        * were expired via :meth:`.Session.expire`</span>

<span class="sd">        * were expired as the natural effect of committing a session</span>
<span class="sd">          transaction, e.g. :meth:`.Session.commit`</span>

<span class="sd">        * are normally :term:`lazy loaded` but are not currently loaded</span>

<span class="sd">        * are &quot;deferred&quot; via :ref:`deferred` and are not yet loaded</span>

<span class="sd">        * were not present in the query which loaded this object, such as that</span>
<span class="sd">          which is common in joined table inheritance and other scenarios.</span>

<span class="sd">        After :func:`.make_transient` is called, unloaded attributes such</span>
<span class="sd">        as those above will normally resolve to the value ``None`` when</span>
<span class="sd">        accessed, or an empty collection for a collection-oriented attribute.</span>
<span class="sd">        As the object is transient and un-associated with any database</span>
<span class="sd">        identity, it will no longer retrieve these values.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.make_transient_to_detached`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">])</span>

    <span class="c1"># remove expired state</span>
    <span class="n">state</span><span class="o">.</span><span class="n">expired_attributes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c1"># remove deferred callables</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span>

    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>


<span class="k">def</span> <span class="nf">make_transient_to_detached</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make the given transient instance :term:`detached`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        :func:`.make_transient_to_detached` is a special-case function for</span>
<span class="sd">        advanced use cases only.</span>

<span class="sd">    All attribute history on the given instance</span>
<span class="sd">    will be reset as though the instance were freshly loaded</span>
<span class="sd">    from a query.  Missing attributes will be marked as expired.</span>
<span class="sd">    The primary key attributes of the object, which are required, will be made</span>
<span class="sd">    into the &quot;key&quot; of the instance.</span>

<span class="sd">    The object can then be added to a session, or merged</span>
<span class="sd">    possibly with the load=False flag, at which point it will look</span>
<span class="sd">    as if it were loaded that way, without emitting SQL.</span>

<span class="sd">    This is a special use case function that differs from a normal</span>
<span class="sd">    call to :meth:`.Session.merge` in that a given persistent state</span>
<span class="sd">    can be manufactured without any SQL calls.</span>

<span class="sd">    .. versionadded:: 0.9.5</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.make_transient`</span>

<span class="sd">        :meth:`.Session.enable_relationship_loading`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">or</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Given object must be transient&quot;</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">unloaded_expirable</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which the given instance belongs.</span>

<span class="sd">    This is essentially the same as the :attr:`.InstanceState.session`</span>
<span class="sd">    accessor.  See that attribute for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="n">_new_sessionid</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">counter</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
    <a id="sidebar-anchor"></a>
    

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007 - 2019, Doyle Rowland.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>